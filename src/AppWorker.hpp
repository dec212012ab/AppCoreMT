#ifndef __APPWORKER_HPP__
#define __APPWORKER_HPP__

#include <chrono>
#include <functional>
#include <iostream>
#include <list>
#include "SafeVar.hpp"
#include "TaskChain.hpp"

namespace AppCore{

class AppWorker{
public:
	using Ptr = std::shared_ptr<AppWorker>;

	/**
	 * @brief Construct a new App Worker object
	 * 
	 */
	AppWorker():worker_id(AppWorker::worker_id_gen++){
		std::stringstream ss;
		ss<<worker_id;
		worker_name = "Worker-"+ss.str();
	};

	/**
	 * @brief Construct a new App Worker object with the specified name.
	 * 
	 * @param name : Name to assign the newly constructed worker.
	 */
	AppWorker(std::string name):worker_id(AppWorker::worker_id_gen++),worker_name(name){};
	~AppWorker()=default;

	/**
	 * @brief Main function executed by workers once the underlying thread
	 * has been started.
	 * 
	 * @param allow_task_exceptions : If false, exceptions generated by tasks are handled internally.
	 * @param task_priority_filter : [WIP] Assigns a priority filter value to the worker.
	 * @return int 
	 */
	int workerMain(bool allow_task_exceptions, int task_priority_filter=-1);

	/**
	 * @brief Function which allows for a user-defined main function to be used
	 * in place of workerMain().
	 * 
	 * @param fn : Function object to use in place of workerMain().
	 */
	void setCustomWorkerMain(std::function<int(size_t,SafeVar<std::list<TaskChain::Ptr>>&,bool,int)> fn){_main=fn;};
	
	/**
	 * @brief Query the worker state in a thread-safe fashion.
	 * 
	 * @return true if the worker is active and running
	 * @return false if the worker is not running
	 */
	bool getRunning(){
		running.lock();
		bool ret = running;
		running.unlock();
		return ret;
	};

	/**
	 * @brief Get the Stop Flag state
	 * 
	 * @return true if the stop flag was set
	 * @return false if the stop flag was not set
	 */
	bool getStopFlag(){return signal_stop;};

	/**
	 * @brief Get the unique id of this worker object.
	 * 
	 * @return size_t 
	 */
	size_t getWorkerID(){return worker_id;};

	/**
	 * @brief Get a reference to the task list in a thread-safe manner
	 * 
	 * @return SafeVar<std::list<TaskChain::Ptr>>& 
	 */
	SafeVar<std::list<TaskChain::Ptr>>& getTaskChainList(){return task_chain_list;};	

	/**
	 * @brief Get the worker's name
	 * 
	 * @return std::string 
	 */
	std::string getWorkerName(){return worker_name;};

	/**
	 * @brief Enqueue a new TaskChain instance to the task queue.
	 * 
	 * @param p : Pointer to the TaskChain instance to be enqueued.
	 */
	void enqueueTaskChain(TaskChain::Ptr p);
	//void enqueueTaskChain(TaskChain&& t);

	/**
	 * @brief Initializes the underlying thread with workerMain() or 
	 * a user-defined replacement main function. This function returns only
	 * after the worker's main function has started and reported its state as
	 * 'running'
	 * 
	 * @param allow_task_exceptions : If false, exceptions triggered by an executed task are handled internally.
	 * @param task_priority_filter : [WIP] Sets the task priority filter value
	 */
	void run(bool allow_task_exceptions=true, int task_priority_filter=-1);

	/**
	 * @brief Stops the worker and returns after the underlying thread has been joined.
	 * 
	 */
	void stop();

private:
	static size_t worker_id_gen; ///< Unique id for workers are generated by this static counter
	size_t worker_id; ///< Unique numerical id for this worker
	std::string worker_name; ///< Name of this worker
	SafeVar<bool> running=false; ///< Thread-safe boolean which holds the worker state
	bool run_finished = false; ///< Internal synchronization variable which is set when the run function completes
	bool signal_stop = false; ///< Flag which indicates this worker should be stopped
	std::function<int(size_t,SafeVar<std::list<TaskChain::Ptr>>&,bool,int)> _main; ///< Function object used to hold alternative worker main implementations
	SafeVar<std::list<TaskChain::Ptr>> task_chain_list; ///< Thread-safe variable holding a pointer to this worker's task queue
	std::shared_ptr<std::thread> _worker; ///< Handle to the underlying thread
};

}
#endif
